.\"
.\" Copyright (c) 2014-2015, Intel Corporation
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\"     * Redistributions of source code must retain the above copyright
.\"       notice, this list of conditions and the following disclaimer.
.\"
.\"     * Redistributions in binary form must reproduce the above copyright
.\"       notice, this list of conditions and the following disclaimer in
.\"       the documentation and/or other materials provided with the
.\"       distribution.
.\"
.\"     * Neither the name of Intel Corporation nor the names of its
.\"       contributors may be used to endorse or promote products derived
.\"       from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.\" "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
.\" A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
.\" OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
.\" SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
.\" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
.\" OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.\"
.\" libpmemobj.3 -- man page for libpmemobj
.\"
.\" Format this man page with:
.\"	man -l libpmemobj.3
.\" or
.\"	groff -man -Tascii libpmemobj.3
.\"
.TH libpmemobj 3 "pmemobj API version 0.4.3" "NVM Library"
.SH NAME
libpmemobj \- persistent memory transactional object store
.SH SYNOPSIS
.nf
.B #include <libpmemobj.h>
.sp
.B cc ... -lpmemobj -lpmem
.sp
.B Most commonly used functions:
.sp
.BI "PMEMobjpool *pmemobj_open(const char *" path ", const char *" layout );
.BI "PMEMobjpool *pmemobj_create(const char *" path ", const char *" layout ,
.BI "    size_t " poolsize ", mode_t " mode );
.BI "PMEMobjpool *pmemobj_create_part(const char *" path ", const char *" layout,
.BI "    size_t " partsize ", mode_t " mode ", int " part_index ", int " nparts,
.BI "    int " replica_index ", int " nreplica );
.BI "void pmemobj_close(PMEMobjpool *" pop );
.sp
.B Locking:
.sp
.BI "void pmemobj_mutex_zero(PMEMobjpool *" pop ", PMEMmutex *" mutexp );
.BI "int pmemobj_mutex_lock(PMEMobjpool *" pop ", PMEMmutex *" mutexp );
.BI "int pmemobj_mutex_trylock(PMEMobjpool *" pop ", PMEMmutex *" mutexp );
.BI "int pmemobj_mutex_unlock(PMEMobjpool *" pop ", PMEMmutex *" mutexp );
.sp
.BI "void pmemobj_rwlock_zero(PMEMobjpool *" pop ", PMEMrwlock *" rwlockp );
.BI "int pmemobj_rwlock_rdlock(PMEMobjpool *" pop ", PMEMrwlock *" rwlockp );
.BI "int pmemobj_rwlock_wrlock(PMEMobjpool *" pop ", PMEMrwlock *" rwlockp );
.BI "int pmemobj_rwlock_timedrdlock(PMEMobjpool *" pop,
.BI "    PMEMrwlock *restrict " rwlockp ",
.BI "    const struct timespec *restrict "abstime );
.BI "int pmemobj_rwlock_timedwrlock(PMEMobjpool *" pop ,
.BI "    PMEMrwlock *restrict " rwlockp ,
.BI "    const struct timespec *restrict " abstime );
.BI "int pmemobj_rwlock_tryrdlock(PMEMobjpool *" pop ", PMEMrwlock * "rwlockp );
.BI "int pmemobj_rwlock_trywrlock(PMEMobjpool *" pop ", PMEMrwlock *" rwlockp );
.BI "int pmemobj_rwlock_unlock(PMEMobjpool *" pop ", PMEMrwlock *" rwlockp );
.sp
.BI "void pmemobj_cond_zero(PMEMobjpool *" pop ", PMEMcond *" condp );
.BI "int pmemobj_cond_broadcast(PMEMobjpool *" pop ", PMEMcond *" condp );
.BI "int pmemobj_cond_signal(PMEMobjpool *" pop ", PMEMcond *" condp );
.BI "int pmemobj_cond_timedwait(PMEMobjpool *" pop ", PMEMcond *restrict " condp ,
.BI "    PMEMmutex *restrict " mutexp ", const struct timespec *restrict " abstime );
.BI "int pmemobj_cond_wait(PMEMobjpool *" pop ", PMEMcond *" condp ,
.BI "    PMEMmutex *restrict " mutexp );
.sp
.B Non-transactional atomic allocations:
.sp
.BI "PMEMoid pmemobj_alloc(PMEMobjpool *" pop ", size_t " size ", int " type_num );
.BI "PMEMoid pmemobj_alloc_construct(PMEMobjpool *" pop ", size_t " size ", int " type_num ,
.BI "    void (*" constructor ")(void *" ptr ", void *" arg "), void *" arg );
.BI "PMEMoid pmemobj_zalloc(PMEMobjpool *" pop ", size_t " size ", int " type_num );
.BI "PMEMoid pmemobj_realloc(PMEMobjpool *" pop ", PMEMoid " oid ", size_t " size ,
.BI "    int " type_num );
.BI "PMEMoid pmemobj_zrealloc(PMEMobjpool *" pop ", PMEMoid " oid ", size_t " size ,
.BI "    int " type_num );
.BI "PMEMoid pmemobj_strdup(PMEMobjpool *" pop ", const char *" s ", int " type_num );
.BI "void pmemobj_free(PMEMoid " oid );
.BI "size_t pmemobj_alloc_usable_size(PMEMoid " oid );
.BI "void *pmemobj_direct(PMEMoid " oid );
.sp
.B Type-safety
.sp
.BI "OID_TYPE(" TYPE )
.sp
.BI "OID_ASSIGN(OID_TYPE " oid ", " VALUE )
.BI "OID_ASSIGN_TYPED(OID_TYPE " lhs ", OID_TYPE " rhs )
.sp
.BI "OID_IS_NULL(OID_TYPE " oid )
.BI "OID_EQUALS(OID_TYPE " lhs ", OID_TYPE " rhs )
.BI "DIRECT_RW(OID_TYPE " oid )
.BI "DIRECT_RO(OID_TYPE " oid )
.BI "D_RW(OID_TYPE " oid )
.BI "D_RO(OID_TYPE " oid )
.sp
.B Root object management:
.sp
.BI "PMEMoid pmemobj_root(PMEMobjpool *" pop ", size_t " size );
.BI "size_t pmemobj_root_size(PMEMobjpool *" pop );
.sp
.B Object containers:
.sp
.BI "PMEMoid pmemobj_first(PMEMobjpool *" pop ", int "type_num );
.BI "PMEMoid pmemobj_next(PMEMoid " oid );
.sp
.BI "PMEMOBJ_FOREACH(PMEMobjpool *" pop ", PMEMoid " varoid ", int " vartype_num );
.BI "PMEMOBJ_FOREACH_SAFE(PMEMobjpool *" pop ", PMEMoid " varoid ", PMEMoid " nvaroid ", int " vartype_num );
.BI "PMEMOBJ_FOREACH_TYPE(PMEMobjpool *" pop ", OID_TYPE " var ", int " type_num );
.BI "PMEMOBJ_FOREACH_SAFE_TYPE(PMEMobjpool *" pop ", OID_TYPE " var ", OID_TYPE " nvar ", int " type_num );
.sp
.B Non-transactional persistent atomic circular doubly-linked list:
.sp
.BI "int pmemobj_list_insert(PMEMobjpool *" pop ", size_t " pe_offset ", PMEMoid " dest ,
.BI "    PMEMoid *" head ", int " before ", PMEMoid " oid );
.BI "PMEMoid pmemobj_list_insert_new(PMEMobjpool *" pop ", size_t " pe_offset ", PMEMoid " dest ,
.BI "    PMEMoid *" head ", int " before ", size_t " size ", int " type_num ,
.BI "    void (*" constructor ")(void *" ptr ", void *" arg "), void *" arg );
.BI "int pmemobj_list_remove(PMEMobjpool *" pop ", size_t " pe_offset ", PMEMoid " oid ,
.BI "    PMEMoid *" head ", int " free );
.BI "int pmemobj_list_move(PMEMobjpool *" pop ,
.BI "    size_t " pe_old_offset ", size_t " pe_new_offset ,
.BI "    PMEMoid *" head_old ", PMEMoid *" head_new ", int " tail ", PMEMoid " oid );
.sp
.BI "POBJ_LIST_ENTRY(" TYPE )
.BI "POBJ_LIST_HEAD(" HEADNAME ", " TYPE )
.sp
.BI "POBJ_LIST_FIRST(POBJ_LIST_HEAD *" head )
.BI "POBJ_LIST_LAST(POBJ_LIST_HEAD *" head ", POBJ_LIST_ENTRY " FIELD )
.BI "POBJ_LIST_EMPTY(POBJ_LIST_HEAD *" head )
.BI "POBJ_LIST_NEXT(OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD )
.BI "POBJ_LIST_PREV(OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD )
.sp
.BI "POBJ_LIST_FOREACH(OID_TYPE " var ", POBJ_LIST_HEAD *" head ", POBJ_LIST_ENTRY " FIELD )
.BI "POBJ_LIST_FOREACH_REVERSE(OID_TYPE " var ", POBJ_LIST_HEAD *" head ", POBJ_LIST_ENTRY " FIELD )
.sp
.BI "POBJ_LIST_INSERT_HEAD(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.BI "    OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD )
.BI "POBJ_LIST_INSERT_TAIL(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.BI "    OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD )
.BI "POBJ_LIST_INSERT_AFTER(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.BI "    OID_TYPE " listelm ", OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD )
.BI "POBJ_LIST_INSERT_BEFORE(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.BI "    OID_TYPE " listelm ", OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD )
.BI "POBJ_LIST_INSERT_NEW_HEAD(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.BI "    int " type_num ", POBJ_LIST_ENTRY " FIELD ,
.BI "    void (*" constructor ")(void *" ptr ", void *" arg "), void *" arg );
.BI "POBJ_LIST_INSERT_NEW_TAIL(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.BI "    int " type_num ", POBJ_LIST_ENTRY " FIELD ,
.BI "    void (*" constructor ")(void *" ptr ", void *" arg "), void *" arg );
.BI "POBJ_LIST_INSERT_NEW_AFTER(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.BI "    OID_TYPE " listelm ", int " type_num ", POBJ_LIST_ENTRY " FIELD ,
.BI "    void (*" constructor ")(void *" ptr ", void *" arg "), void *" arg );
.BI "POBJ_LIST_INSERT_NEW_BEFORE(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.BI "    OID_TYPE " listelm ", int " type_num ", POBJ_LIST_ENTRY " FIELD ,
.BI "    void (*" constructor ")(void *" ptr ", void *" arg "), void *" arg );
.BI "POBJ_LIST_REMOVE(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.BI "    OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD )
.BI "POBJ_LIST_REMOVE_FREE(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.BI "    OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD )
.BI "POBJ_LIST_MOVE_ELEMENT_HEAD(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.BI "    POBJ_LIST_HEAD *" head_new ", OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD ",
.BI "    POBJ_LIST_ENTRY " field_new )
.BI "POBJ_LIST_MOVE_ELEMENT_TAIL(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.BI "    POBJ_LIST_HEAD *" head_new ", OID_TYPE " elm ",POBJ_LIST_ENTRY " FIELD ",
.BI "    POBJ_LIST_ENTRY " field_new )
.sp
.B Transactional object manipulation:
.sp
.BI "enum tx_stage pmemobj_tx_stage();
.sp
.BI "int pmemobj_tx_begin(PMEMobjpool *" pop ", jmp_buf *" env ", enum " tx_lock ", " ... );
.BI "void pmemobj_tx_abort(int " errnum );
.BI "int pmemobj_tx_commit();
.BI "void pmemobj_tx_end();
.BI "int pmemobj_tx_process();
.sp
.BI "int pmemobj_tx_add_range(uint64_t " off ", size_t " size );
.BI "PMEMoid pmemobj_tx_alloc(size_t " size ", int " type_num );
.BI "PMEMoid pmemobj_tx_zalloc(size_t " size ", int " type_num );
.BI "PMEMoid pmemobj_tx_realloc(PMEMoid " oid ", size_t " size ", int " type_num );
.BI "PMEMoid pmemobj_tx_zrealloc(PMEMoid " oid ", size_t " size ", int " type_num );
.BI "PMEMoid pmemobj_tx_strdup(const char *" s ", int " type_num );
.BI "int pmemobj_tx_free(PMEMoid " oid );
.sp
.BI "TX_BEGIN_LOCK(PMEMobjpool *" pop ", " ... )
.BI "TX_BEGIN(PMEMobjpool *" pop )
.BI "TX_ONABORT
.BI "TX_ONCOMMIT
.BI "TX_FINALLY
.BI "TX_END
.sp
.BI "TX_ADD(OID_TYPE " o )
.BI "TX_ADD_FIELD(OID_TYPE " o ", " FIELD )
.sp
.BI "TX_ALLOC(" TYPE ", int " type_num )
.BI "TX_ZALLOC(" TYPE ", int " type_num )
.BI "TX_REALLOC(OID_TYPE " o ", size_t " size ", int " type_num )
.BI "TX_ZREALLOC(OID_TYPE " o ", size_t " size ", int " type_num )
.BI "TX_STRDUP(const char *" s ", int " type_num )
.BI "TX_FREE(OID_TYPE " o )
.sp
.BI "TX_SET(OID_TYPE " o ", " FIELD ", " VALUE )
.BI "TX_MEMCPY(OID_TYPE " o ", " FIELD ", const void *" src ", size_t " num )
.BI "TX_MEMSET(OID_TYPE " o ", " FIELD ", int " c ", size_t " num )
.sp
.B Library API versioning:
.sp
.BI "const char *pmemobj_check_version("
.BI "    unsigned " major_required ,
.BI "    unsigned " minor_required );
.sp
.B Managing library behavior:
.sp
.BI "void pmemobj_set_funcs("
.BI "    void *(*" malloc_func ")(size_t " size ),
.BI "    void (*" free_func ")(void *" ptr ));
.BI "int pmemobj_check(const char *" path ", const char *" layout );
.fi
.sp
.SH DESCRIPTION
.PP
.B libpmemobj
provides a transactional object store in
.I persistent memory
(pmem).
This library is intended for applications
using direct access storage (DAX),
which is storage that supports load/store access without
paging blocks from a block storage device.
Some types of
.I non-volatile memory DIMMs
(NVDIMMs)
provide this type of byte addressable access to storage.
A
.I persistent memory aware file system
is typically used to expose the direct access to applications.
Memory mapping a file from this type of file system
results in the load/store, non-paged access to pmem.
.B libpmemobj
builds on this type of memory mapped file.
.PP
This library is for applications that need a transactions
and persistent memory management.
This library builds on the low-level pmem support provided by
.BR libpmem ,
handling the transactional updates, flushing changes to
persistence, and recovery for the application.
.PP
.B libpmemobj
is one of a collection of persistent memory libraries available,
the others are:
.IP
.BR libpmemblk (3),
providing pmem-resident arrays of fixed-sized blocks with atomic updates.
.IP
.BR libpmemlog (3),
providing a pmem-resident log file.
.IP
.BR libpmem (3),
low-level persistent memory support.
.PP
Under normal usage,
.B libpmemobj
will never print messages or intentionally cause the process to exit.
The only exception to this is the debugging information, when enabled, as
described under
.B DEBUGGING
below.
.SH MOST COMMONLY USED FUNCTIONS
.PP
To use the pmem-resident transactional object store provided by
.BR libpmemobj ,
a
.I memory pool
is first created.  This is done with the
.BR pmemobj_create ()
function described in this section.
The other functions
described in this section then operate on the resulting
memory pool.
.PP
Once created, the memory pool is represented by an opaque handle,
of type
.IR "PMEMobjpool *" ,
which is passed to most of the other functions in this section.
Internally,
.B libpmemobj
will use either
.BR pmem_persist ()
or
.BR msync (2)
when it needs to flush changes, depending on whether
the memory pool appears to be persistent memory or a regular file
(see the
.BR pmem_is_pmem ()
function in
.BR libpmem (3)
for more information).
There is no need for applications to flush changes directly
when using the obj memory API provided by
.BR libpmemobj .
.PP
.BI "PMEMobjpool *pmemobj_open(const char *" path ", const char *" layout );
.IP
The
.B pmemobj_open ()
function opens an existing object store memory pool,
returning a memory pool handle used with most of the functions in this section.
.I path
must be an existing file containing a pmemobj memory pool as
created by
.BR pmemobj_create ().
If
.I layout
is non-NULL, it is compared to the layout name provided to
.BR pmemobj_create ()
when the pool was first created.  This can be used to verify
the layout of the pool matches what was expected.
The application must have permission to open the file and memory map
it with read/write permissions.
If an error prevents the pool from being opened,
or if the given
.I layout
does not match the pool's layout,
.BR pmemobj_open ()
returns NULL and sets errno appropriately.
.PP
.BI "PMEMobjpool *pmemobj_create(const char *" path ", const char *" layout ,
.br
.BI "    size_t " poolsize ", mode_t " mode );
.IP
The
.BR pmemobj_create ()
function creates a transactional object store with the given total
.IR poolsize .
.I path
specifies the name of the memory pool file to be created.
.I layout
specifies the application's layout type in the form of a string.
The layout name is not interpreted by
.BR libpmemobj ,
but may be used as a check when
.BR pmemobj_open ()
is called.
The layout name, including the null termination, cannot be longer than
.B PMEMOBJ_MAX_LAYOUT
as defined in
.BR <libpmemobj.h> .
.I mode
specifies the permissions to use when creating the file
as described by
.BR creat (2).
The memory pool file is fully allocated to the size
.I poolsize
using
.BR posix_fallocate (3).
The caller may choose to take responsibility for creating the memory
pool file by creating it before calling
.BR pmemobj_create ()
and then specifying
.I poolsize
as zero.  In this case
.BR pmemobj_create ()
will take the pool size from the size of the existing file and will
verify that the file appears to be empty by searching for any non-zero
data in the pool header at the beginning of the file.
The minimum
file size allowed by the library for a transactional object store is defined in
.B <libpmemobj.h>
as
.BR PMEMOBJ_MIN_POOL .
.PP
.BI "void pmemobj_close(PMEMobjpool *" pop );
.IP
The
.BR pmemobj_close ()
function closes the memory pool indicated by
.I pop
and deletes the memory pool handle.  The object store
itself lives on in the file that contains it and may be re-opened
at a later time using
.BR pmemobj_open ()
as described above.
.SH POOL SETS AND REPLICAS
.PP
Depending on the configuration of the system, the available space of
non-volatile memory space may be divided into multiple memory devices.
In such case, the maximum size of the transactional object store could be
limited by the capacity of a single memory device.
The
.B libpmemobj
allows building transactional object stores spanning multiple memory devices
by creation of persistent memory pools consisting of multiple files, where
each part of such a
.I pool set
may be stored on different pmem-aware filesystem.
.PP
To improve reliability and eliminate the single point of failure, all the
changes of the data stored in the persistent memory pool
could be also automatically written to a local or remote pool replicas,
thereby providing a backup for a persistent memory pool by producing a
.IR "mirrored pool set" .
In practice, the pool replicas may be considered the binary copies of
the "master" pool set.
.PP
Creation of each specific part of the pool set or the replica set can be done
with the
.BR pmemobj_create_part ()
function described below.
However, the recommended method for creating pool sets and replicas
is to do it by using the
.BR pmempool (1)
utility.
.PP
.BI "PMEMobjpool *pmemobj_create_part(const char *" path ", const char *" layout,
.br
.BI "    size_t " partsize ", mode_t " mode ", int " part_index ", int " nparts,
.br
.BI "    int " replica_index ", int " nreplica );
.IP
The
.BR pmemobj_create_part ()
function creates a part of transactional object store of the size specified by
.IR partsize .
The
.I path
argument specifies the name of the memory pool part file to be created.
The meaning of
.I layout
and
.I mode
arguments is the same as for
.BR pmemobj_create ().
.IP
The
.I part_index
and
.I nparts
arguments specify the index of given part and the total number of parts
in the pool set.  Similarly,
.I replica_index
and
.I nreplica
specify the replica index and the total number of replicas.
.PP
When opening the pool set consisting of multiple files, or when opening the
replicated pool set, the
.I path
argument passed to
.BR pmemobj_open ()
must not point to the pmemobj memory pool file, but to the special
.I set
file that defines the pool layout and the location of all the parts of
the pool set.  If the error prevents any of the pool set files from being open,
.BR pmemobj_open ()
returns NULL and sets errno appropriately.
.PP
The set file is a plain
text file, which must start with the line containing a
.I "PMEMPOOLSET"
string,
followed by the specification of all the pool parts in the next lines.
For each part, the file size and the full path must be provided.
Sections defining the replica sets are optional.  There could be multiple
replica sections and each must start with the line containing a
.I "REPLICA"
string.
Lines starting with "#" character are ignored.
.PP
Here is the example "myobjpool.set" file:
.IP
.nf
PMEMPOOLSET
100G /mountpoint0/myfile.part0
200G /mountpoint1/myfile.part1
400G /mountpoint2/myfile.part2
REPLICA
500G /mountpoint3/mymirror.part0
200G /mountpoint4/mymirror.part1
.fi
.PP
The files in the set may be created by running the following command:
.IP
.nf
pmempool create obj --layout="mylayout" --from-set=myobjpool.set
.fi
.PP
This is equivalent to making these calls:
.IP
.nf
pmemobj_create_part("/mountpoint0/myfile.part0", "mylayout",
                        100 * SZ_1G, 0666, 0, 3, 0, 2);
pmemobj_create_part("/mountpoint1/myfile.part1", "mylayout",
                        200 * SZ_1G, 0666, 1, 3, 0, 2);
pmemobj_create_part("/mountpoint2/myfile.part2", "mylayout",
                        400 * SZ_1G, 0666, 2, 3, 0, 2);
pmemobj_create_part("/mountpoint3/mymirror.part0", "mylayout",
                        500 * SZ_1G, 0666, 0, 2, 1, 2);
pmemobj_create_part("/mountpoint4/mymirror.part1", "mylayout",
                        200 * SZ_1G, 0666, 1, 2, 1, 2);
.fi
.SH LOCKING
.PP
.B libpmemobj
provides several types of synchronization primitives, designed so as to use
them with persistent memory.  The locks are not dynamically allocated,
but embedded in pmem-resident objects.  For performance reasons, they
are also padded up to 64 bytes (cache line size).
.PP
Pmem-aware locks implementation is based on the standard POSIX Thread Library,
as described in
.BR pthread_mutex (3),
.BR pthread_rwlock (3)
and
.BR pthread_cond (3).
They provide semantics similar to standard
.BR pthread
locks, except that they are considered initialized by zeroing them.
So allocating the locks with
.BR pmemobj_zalloc ()
or
.BR pmemobj_tx_zalloc ()
does not require another initialization step.
.PP
The fundamental property of pmem-aware locks is their automatic
reinitialization every time the persistent object store pool is open.
This way, all the pmem-aware locks may be considered initialized (unlocked)
right after opening the pool, regardless of their state at the time the pool
was closed for the last time.
.PP
Pmem-aware mutexes, read/write locks or condition variables must be declared
with one of the
.IR PMEMmutex ,
.IR PMEMrwlock ,
or
.IR PMEMcond
type respectively.
.PP
.BI "void pmemobj_mutex_zero(PMEMobjpool *" pop ", PMEMmutex *" mutexp );
.IP
The
.BR pmemobj_mutex_zero ()
function explicitly initializes pmem-aware mutex pointed by
.I mutexp
by zeroing it.
Initialization is not necessary if the object containing the mutex has been
allocated using one of
.BR pmemobj_zalloc ()
or
.BR pmemobj_tx_zalloc ()
functions.
.PP
The above interfaces provide the same semantics as the corresponding functions
defined in
.BR pthread_rwlock (3) .
.PP
.BI "int pmemobj_mutex_lock(PMEMobjpool *" pop ", PMEMmutex *" mutexp );
.IP
The
.BR pmemobj_mutex_lock ()
function locks pmem-aware mutex pointed by
.IR mutexp .
If the mutex is already locked, the calling thread will block until the
mutex becomes available.
If this is the first use of the mutex since opening of the pool
.IR pop ,
the mutex is automatically reinitialized and then locked.
.PP
.BI "int pmemobj_mutex_trylock(PMEMobjpool *" pop ", PMEMmutex *" mutexp );
.IP
The
.BR pmemobj_mutex_trylock ()
function locks pmem-aware mutex pointed by
.IR mutexp .
If the mutex is already locked,
.BR pthread_mutex_trylock()
will not block waiting for the mutex, but will return an error condition.
If this is the first use of the mutex since opening of the pool
.I pop
the mutex is automatically reinitialized and then locked.
.PP
.BI "int pmemobj_mutex_unlock(PMEMobjpool *" pop ", PMEMmutex *" mutexp );
.IP
The
.BR pmemobj_mutex_unlock ()
function unlocks an acquired pmem-aware mutex pointed by
.IR mutexp .
Undefined behavior follows if a thread tries to unlock a mutex that has
not been locked by it, or if a thread tries to release a mutex that is already
unlocked or not initialized.
.PP
.BI "void pmemobj_rwlock_zero(PMEMobjpool *" pop ", PMEMrwlock *" rwlockp );
.IP
The
.BR pmemobj_rwlock_zero ()
function is used to explicitly initialize pmem-aware read/write lock pointed
by
.I rwlockp
by zeroing it.
Initialization is not necessary if the object containing the lock has been
allocated using one of
.BR pmemobj_zalloc ()
or
.BR pmemobj_tx_zalloc ()
functions.
.PP
.BI "int pmemobj_rwlock_rdlock(PMEMobjpool *" pop ", PMEMrwlock *" rwlockp );
.IP
The
.BR pmemobj_rwlock_rdlock ()
function acquires a read lock on
.I rwlockp
provided that lock is not presently held for writing and no writer
threads are presently blocked on the lock.  If the read lock cannot be
immediately acquired, the calling thread blocks until it can acquire the
lock.
If this is the first use of the lock since opening of the pool
.IR pop ,
the lock is automatically reinitialized and then acquired.
.PP
.BI "int pmemobj_rwlock_timedrdlock(PMEMobjpool *" pop,
.br
.BI "    PMEMrwlock *restrict " rwlockp ",
.br
.BI "    const struct timespec *restrict "abstime );
.IP
The
.BR pmemobj_rwlock_timedrdlock ()
performs the same action, but will not wait beyond
.I abstime
to obtain the lock before returning.
.PP
A thread may hold multiple concurrent read locks.  If so,
.BR pmemobj_rwlock_unlock ()
must be called once for each lock obtained.
.PP
The results of acquiring a read lock while the calling thread holds a
write lock are undefined.
.PP
.BI "int pmemobj_rwlock_wrlock(PMEMobjpool *" pop ", PMEMrwlock *" rwlockp );
.IP
The
.BR pmemobj_rwlock_wrlock ()
function blocks until a write lock can be acquired against lock pointed by
.IR rwlockp .
If this is the first use of the lock since opening of the pool
.IR pop ,
the lock is automatically reinitialized and then acquired.
.PP
.BI "int pmemobj_rwlock_timedwrlock(PMEMobjpool *" pop ,
.br
.BI "    PMEMrwlock *restrict " rwlockp ,
.br
.BI "    const struct timespec *restrict " abstime );
.IP
The
.BR pmemobj_rwlock_timedwrlock ()
performs the same action, but will not wait beyond
.I abstime
to obtain the lock before returning.
.PP
.BI "int pmemobj_rwlock_trywrlock(PMEMobjpool *" pop ", PMEMrwlock *" rwlockp );
.IP
The
.BR pmemobj_rwlock_tryrdlock ()
function performs the same action as
.BR pmemobj_rwlock_rdlock () ,
but does not block if the lock cannot be immediately obtained.
.PP
The results are undefined if the calling thread already holds the lock at
the time the call is made.
.PP
.BI "int pmemobj_rwlock_trywrlock(PMEMobjpool *" pop ", PMEMrwlock *" rwlockp );
.IP
The
.BR pmemobj_rwlock_trywrlock ()
function performs the same action as
.BR pmemobj_rwlock_wrlock () ,
but does not block if the lock cannot be immediately obtained.
.PP
The results are undefined if the calling thread already holds the lock at
the time the call is made.
.PP
.BI "int pmemobj_rwlock_unlock(PMEMobjpool *" pop ", PMEMrwlock *" rwlockp );
.IP
The
.BR pmemobj_rwlock_unlock ()
function is used to release the read/write lock previously obtained by
.BR pmemobj_rwlock_rdlock (),
.BR pmemobj_rwlock_wrlock (),
.BR pthread_rwlock_tryrdlock (),
or
.BR pmemobj_rwlock_trywrlock ().
.PP
.BI "void pmemobj_cond_zero(PMEMobjpool *" pop ", PMEMcond *" condp );
.IP
The
.BR pmemobj_cond_zero ()
function explicitly initializes pmem-aware condition variable by zeroing it.
Initialization is not necessary if the object containing the condition
variable has been allocated using one of
.BR pmemobj_zalloc ()
or
.BR pmemobj_tx_zalloc ()
functions.
.PP
.BI "int pmemobj_cond_broadcast(PMEMobjpool *" pop ", PMEMcond *" condp );
.sp
.BI "int pmemobj_cond_signal(PMEMobjpool *" pop ", PMEMcond *" condp );
.IP
The difference between
.BR pmemobj_cond_broadcast ()
and
.BR pmemobj_cond_signal ()
is that the former unblocks all threads waiting for the condition
variable, whereas the latter blocks only one waiting thread.  If no
threads are waiting on
.IR cond ,
neither function has any effect.  If more than one thread is blocked
on a condition variable, the used scheduling policy determines the order
in which threads are unblocked.  The same mutex used for waiting must be held
while calling either function.  Although neither function strictly enforces
this requirement, undefined behavior may follow if the mutex is not held.
.PP
.BI "int pmemobj_cond_timedwait(PMEMobjpool *" pop ", PMEMcond *restrict " condp ,
.br
.BI "    PMEMmutex *restrict " mutexp ,
.br
.BI "    const struct timespec *restrict " abstime );
.sp
.BI "int pmemobj_cond_wait(PMEMobjpool *" pop ", PMEMcond *" condp ,
.br
.BI "    PMEMmutex *restrict " mutexp );
.IP
The
.BR pmemobj_cond_timedwait ()
and
.BR pmemobj_cond_wait ()
functions shall block on a condition variable.  They shall be called with mutex
locked by the calling thread or undefined behavior results.
These functions atomically release mutex pointed by
.I mutexp
and cause the calling thread to block on the condition variable
.IR cond ;
atomically here means "atomically with respect to access by another thread to
the mutex and then the condition variable". That is, if another thread is able
to acquire the mutex after the about-to-block thread has released it, then
a subsequent call to
.BR pmemobj_cond_broadcast ()
or
.BR pmemobj_cond_signal ()
in that thread shall behave as if it were issued after the about-to-block
thread has blocked.
Upon successful return, the mutex shall have been locked and shall be owned by
the calling thread.
.SH PERSISTENT OBJECTS
.PP
Each object stored in persistent memory pool is represented by an
object handle of type
.IR "PMEMoid" .
In practice, such a handle is a unique Object IDentifier (OID) of a global
scope, which means that two objects from different pools may not have the
same OID.  The special
.IR "OID_NULL"
macro defines a NULL-like handle that does not represent any object.
.PP
An OID cannot be considered as a direct pointer to an object.  Each time the
program attempts to read or write object data, it must obtain the current
memory address of the object by converting its OID into the pointer.
.PP
In contrast to the memory address, the OID value for given object does not
change during the life of an object (except for realloc operation), and remains
valid after closing and reopening the pool.  For this reason, if an object
contains a reference to another persistent object - necessary to build
some kind of a linked data structure - it shall never use memory address
of an object, but its OID.
.PP
.BI "void *pmemobj_direct(PMEMoid " oid );
.IP
The
.BR pmemobj_direct ()
function returns a pointer to an object represented by
.IR oid .
If OID_NULL is passed as an argument, function returns NULL.
.PP
At the time of allocation (or reallocation), each object may be assigned
a number representing its type.  Such a
.I type number
may be used to arrange the persistent objects based on their actual
user-defined structure type, thus facilitating implementation of a simple
run-time type safety mechanism.  It also allows to iterate through all the
objects of given type stored in the persistent memory pool.  See
.B OBJECT CONTAINERS
section for more details.
.PP
The
.BR PMEMOBJ_NUM_OID_TYPES
macro defines the limit of valid type numbers.
.SH TYPE-SAFETY
.PP
Operating on untyped object handles, as well as on direct untyped object
pointers (void *) may be confusing and error prone.  To facilitate
implementation of type safety mechanism,
.B libpmemobj
defines a set of macros that provide a static type enforcement,
catching potential errors at compile time.
For example, a compile-time error is generated when an attempt is made
to assign a handle to an object of one type to the object handle variable
of another type of object.
.PP
.BI "OID_TYPE(" TYPE )
.IP
The
.B OID_TYPE
macro declares a handle to an object of type specified by argument
.IR TYPE ,
where
.I TYPE
is the name of a user-defined structure.
.PP
.BI "OID_ASSIGN(OID_TYPE " o ", " VALUE )
.IP
The
.B OID_ASSIGN
macro assigns an object handle specified by
.I VALUE
to the variable
.IR o .
.PP
.BI "OID_ASSIGN_TYPED(OID_TYPE " lhs ", OID_TYPE " rhs )
.IP
The
.B OID_ASSIGN_TYPED
macro assigns an object handle specified by
.I rhs
to the object handle variable
.I lhs
with the static type checking.
Both
.I lhs
and
.I rhs
must be the object handles of the same type.  Otherwise a compile-time error
is generated.
.PP
.BI "OID_IS_NULL(OID_TYPE " o )
.IP
The
.B OID_IS_NULL
macro evaluates to true if the object handle represented by argument
.I o
has OID_NULL value.
.PP
.BI "OID_EQUALS(OID_TYPE " lhs ", OID_TYPE " rhs )
.IP
The
.B OID_EQUALS
macro evaluates to true if both
.I lhs
and
.I rhs
object handles are referencing the same persistent object.
.PP
.BI "DIRECT_RW(OID_TYPE " oid )
.sp
.BI "D_RW(OID_TYPE " oid )
.IP
The
.BR DIRECT_RW ()
macro and its shortened form
.BR D_RW ()
return a typed write pointer (TYPE *) to an object
represented by
.IR oid .
If OID_NULL is passed as an argument, the macro evaluates to NULL.
.PP
.BI "DIRECT_RO(OID_TYPE " oid )
.sp
.BI "D_RO(OID_TYPE " oid )
.IP
The
.BR DIRECT_RO ()
macro and its shortened form
.BR D_RO ()
return a typed read-only (const) pointer (TYPE *) to an object
represented by
.IR oid .
If OID_NULL is passed as an argument, the macro evaluates to NULL.
.SH OBJECT CONTAINERS
.PP
All the objects in the persistent memory pool are organized by their
.I type number
and stored in the internal containers, similar to the lists described in
.B NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS
section.  Each persistent object is added to one of those object
collections at the allocation time.
The number of internal containers is limited by
.BR PMEMOBJ_NUM_OID_TYPES .
.PP
The
.I libpmemobj
provides a mechanism allowing to iterate through the internal object collections,
either looking for a specific object, or performing a specific operation on
each object of given type.
.PP
.BI "PMEMoid pmemobj_first(PMEMobjpool *" pop ", int "type_num );
.IP
The
.BR pmemobj_first ()
function returns the first object from the collection specified by
.IR type_num .
If the collection is empty, OID_NULL is returned.
If the value of
.I type_num
argument exceeds the limit, an OID_NULL is returned and errno is
set appropriately.
.PP
.BI "PMEMoid pmemobj_next(PMEMoid " oid );
.IP
The
.BR pmemobj_next ()
function returns the next object from the same collection as the object
referenced by
.IR oid .
If an object referenced by
.I oid
is the last object in the collection, or if the OID_NULL is passed as
an argument, function returns OID_NULL.
.PP
The following two macros provide more convenient way to iterate through
the internal collections, performing a specific operation on each object.
.PP
.BI "PMEMOBJ_FOREACH(PMEMobjpool *" pop ", PMEMoid " varoid ", int " vartype_num )
.IP
The
.BR PMEMOBJ_FOREACH ()
macro allows to perform a specific operation on each allocated object stored in
the persistent memory pool pointed by
.IR pop .
It traverses the internal collection of all the objects, assigning a handle to
each element in turn to
.I varoid
and its type number to
.I vartype_num
variable.
.PP
.BI "PMEMOBJ_FOREACH_TYPE(PMEMobjpool *" pop ", OID_TYPE " var ", int " type_num )
.IP
.BR PMEMOBJ_FOREACH_TYPE ()
macro allows to perform a specific operation on each allocated object
of the type specified by
.I type_num
argument, stored in the persistent memory pool pointed by
.IR pop .
It traverses the internal collection of all the objects of the specified type,
assigning a handle to each element in turn to
.I var
variable.
.PP
.BI "PMEMOBJ_FOREACH_SAFE(PMEMobjpool *" pop ", PMEMoid " varoid ",
.br
.BI "    PMEMoid " nvaroid ", int " vartype_num )
.sp
.BI "PMEMOBJ_FOREACH_SAFE_TYPE(PMEMobjpool *" pop ", OID_TYPE " var ",
.br
.BI "    PMEMoid " nvar ", int " type_num )
.IP
The macros
.BR POBJ_FOREACH_SAFE ()
and
.BR PMEMOBJ_FOREACH_SAFE_TYPE ()
work in a similar fashion as
.BR PMEMOBJ_FOREACH ()
and
.BR PMEMOBJ_FOREACH_TYPE ()
except that prior to performing the operation on the object, they preserve
a handle to the next object in the collection by assigning it to
.I nvaroid
or
.I nvar
variable.  This allows safe deletion of selected objects while iterating
through the collection.
.SH ROOT OBJECT MANAGEMENT
.PP
The root object of persistent memory pool is an entry point for all other
persistent objects allocated using the
.I libpmemobj
API.  In other words, every single object stored in persistent memory pool
should have the root object at the end of its reference path.
It may be assumed that for each persistent memory pool the root object always
exists, and there is exactly one root object in each pool.
.PP
.BI "PMEMoid pmemobj_root(PMEMobjpool *" pop ", size_t " size );
.IP
The
.BR pmemobj_root ()
function returns a handle to the root object associated with
the persistent memory pool pointed by
.IR pop .
If this is the first call to
.BR pmemobj_root ()
and the root object does not exists yet, it is implicitly allocated in
a thread-safe manner, so if the function is called by more than one
thread simultaneously (with identical
.I size
value), the same root object handle is returned in all the threads.
.IP
The size of the root object is guaranteed to be not less than the requested
.IR size .
If the requested size is larger than the current size, the root object is
automatically resized.  In such case, the old data is preserved and the
extra space is zeroed.
The
.BR pmemobj_root ()
function shall not fail, except for the case if the requested object size
is larger than the maximum allocation size supported for given pool,
or if there is not enough free space in the pool to satisfy the reallocation
of the root object.  In such case, OID_NULL is returned.
.PP
.BI "size_t pmemobj_root_size(PMEMobjpool *" pop );
.IP
The
.BR pmemobj_root_size ()
function returns the current size of the root object associated with
the persistent memory pool pointed by
.IR pop .
The returned size is the largest value requested by any of the earlier
.BR pmemobj_root ()
calls.  0 is returned if the root object has not been allocated yet.
.SH NON-TRANSACTIONAL ATOMIC ALLOCATIONS
.PP
Functions described in this section provide the mechanism to allocate, resize
and free objects from the persistent memory pool in a thread-safe and fail-safe
manner.  All the routines are atomic with respect to other threads and any
power-fail interruptions.  If any of those operations is torn by program failure
or system crash; on recovery they are guaranteed to be entirely completed or
discarded, leaving the persistent memory heap and internal object containers
in a consistent state.
.PP
All these functions can be used outside transactions.  Note that operations
performed using non-transactional API are considered durable after completion,
even if executed within the open transaction.  Such non-transactional changes
will not be rolled-back if the transaction is aborted or interrupted.
.PP
The allocations are always aligned to the cache-line boundary.
.PP
.BI "PMEMoid pmemobj_alloc(PMEMobjpool *" pop ", size_t " size ", int " type_num );
.IP
The
.BR pmemobj_alloc ()
function allocates a new object of given
.I size
from the persistent memory heap associated with memory pool
.IR pop .
The memory is
.I not
initialized.
The allocated object is added to the internal container associated with given
.IR type_num .
The
.I size
can be any non-zero value, however due to internal padding and object metadata,
the actual size of the allocation will differ from the requested one by at least
64 bytes.  For this reason, making the allocations of
a size less than 64 bytes is extremely inefficient and discouraged.
.IP
In contrast to POSIX
.BR malloc (3),
the
.BR pmemobj_alloc ()
always return
.I OID_NULL
when called with
.I size
equal 0.
.PP
.BI "PMEMoid pmemobj_zalloc(PMEMobjpool *" pop ", size_t " size ", int " type_num );
.IP
The
.BR pmemobj_zalloc ()
function allocates a new zeroed object from the the persistent memory heap
associated with memory pool
.IR pop .
The
.I size
can be any non-zero value, however due to internal padding and object metadata,
the actual size of the allocation will differ from the requested one by at least
64 bytes.  For this reason, making the allocations of a size
less than 64 bytes is extremely inefficient and discouraged.
If
.I size
is 0, then
.BR pmemobj_zalloc ()
returns
.IR OID_NULL .
The allocated object is added to the internal container associated with given
.I type_num.
.PP
.BI "PMEMoid pmemobj_alloc_construct(PMEMobjpool *" pop ", size_t " size ",
.br
.BI "    int " type_num ,
.br
.BI "    void (*" constructor ")(void *" ptr ", void *" arg "), void *" arg );
.IP
The
.BR pmemobj_alloc_construct
function allocates a new object from the persistent memory heap
associated with memory pool
.IR pop .
Before returning, it calls the
.BR constructor
function passing the pointer to the newly allocated object in
.I ptr
along with the
.I arg
argument.
It is guaranteed that allocated object is either
properly initialized, or if the allocation is interrupted before the constructor
completes, the memory space reserved for the object is reclaimed.
The
.I size
can be any non-zero value, however due to internal padding and object metadata,
the actual size of the allocation will differ from the requested one by at least
64 bytes.  For this reason, making the allocations of a size
less than 64 bytes is extremely inefficient and discouraged.
If
.I size
is 0, then
.BR pmemobj_alloc_construct ()
returns
.IR OID_NULL .
The allocated object is added to the internal container associated with given
.IR type_num .
.PP
.BI "void pmemobj_free(PMEMoid " oid );
.IP
The
.BR pmemobj_free ()
function provides the same semantics as
.BR free (3),
but instead of the process heap supplied by the system, it operates on the
persistent memory heap.
It frees the memory space represented by
.IR oid ,
which must have been returned by a previous call to
.BR pmemobj_alloc (),
.BR pmemobj_alloc_construct (),
.BR pmemobj_zalloc (),
.BR pmemobj_realloc (),
or
.BR pmemobj_zrealloc ().
If
.I oid
is OID_NULL, no operation is performed.
.PP
.BI "PMEMoid pmemobj_realloc(PMEMobjpool *" pop ", PMEMoid " oid ", size_t " size ,
.br
.BI "    int " type_num );
.IP
The
.BR pmemobj_realloc ()
function provide similar semantics to
.BR realloc (3),
but operates on the persistent memory heap associated with memory pool
.IR pop .
It changes the size of the object represented by
.IR oid ,
to
.I size
bytes.  The resized object is also added or moved to the internal
container associated with given
.IR type_num .
The contents will be unchanged in the range from the start of the region
up to the minimum of the old and new sizes.
If the new size is larger than the old size, the added memory will
.I not
be initialized.
If
.I oid
is
.IR OID_NULL ,
then the call is equivalent to
.IR "pmemobj_alloc(pop, size, type_num)".
If
.I size
is equal to zero, and
.I oid
is not
.IR OID_NULL ,
then the call is equivalent to
.IR "pmemobj_free(oid)".
Unless
.I oid
is OID_NULL, it must have been returned by an earlier call to
.BR pmemobj_alloc (),
.BR pmemobj_alloc_construct (),
.BR pmemobj_zalloc (),
.BR pmemobj_realloc (),
or
.BR pmemobj_zrealloc ().
Note that the object handle value may change in result of reallocation.
If the object was moved, a memory space represented by
.I oid
is reclaimed.
If
.BR pmemobj_realloc ()
is unable to satisfy the allocation request, a OID_NULL is
returned and errno is set appropriately.
.PP
.BI "PMEMoid pmemobj_zrealloc(PMEMobjpool *" pop ", PMEMoid " oid ", size_t " size ,
.br
.BI "    int " type_num );
.IP
The
.BR pmemobj_zrealloc ()
function provide similar semantics to
.BR realloc (3),
but operates on the persistent memory heap associated with memory pool
.IR pop .
It changes the size of the object represented by
.IR oid ,
to
.I size
bytes.  The resized object is also added or moved to the internal
container associated with given
.I type_num .
The contents will be unchanged in the range from the start of the region
up to the minimum of the old and new sizes.
If the new size is larger than the old size, the added memory will be zeroed.
If
.I oid
is
.I OID_NULL,
then the call is equivalent to
.IR "pmemobj_zalloc(poop, size, type_num)".
If
.I size
is equal to zero, and
.I oid
is not
.IR OID_NULL ,
then the call is equivalent to
.IR "pmemobj_free(pop, oid)".
Unless
.I oid
is OID_NULL, it must have been returned by an earlier call to
.BR pmemobj_alloc (),
.BR pmemobj_alloc_construct (),
.BR pmemobj_zalloc (),
.BR pmemobj_realloc (),
or
.BR pmemobj_zrealloc ().
Note that the object handle value may change in result of reallocation.
If the object was moved, a memory space represented by
.I oid
is reclaimed.
If
.BR pmemobj_zrealloc ()
is unable to satisfy the allocation request, a OID_NULL is
returned and errno is set appropriately.
.PP
.BI "PMEMoid pmemobj_strdup(PMEMobjpool *" pop ", const char *" s ", int " type_num );
.IP
The
.BR pmemobj_strdup ()
function provides the same semantics as
.BR strdup (3),
but operates on the persistent memory heap associated with memory pool
.IR pop .
It returns a handle to a new object which is a duplicate of the string
.IR s .
The allocated string object is also added to the internal
container associated with given
.IR type_num .
Memory for the new string is obtained
with
.BR pmemobj_alloc (),
on the given memory pool, and can be freed with
.BR pmemobj_free ()
on the same memory pool.
If
.BR pmemobj_strdup ()
is unable to satisfy the allocation request, a OID_NULL is
returned and errno is set appropriately.
.PP
.BI "size_t pmemobj_alloc_usable_size(PMEMoid " oid );
.IP
The
.BR pmemobj_alloc_usable_size ()
function provides the same semantics as
.BR malloc_usable_size (3),
but instead of the process heap supplied by the system, it operates on the
persistent memory heap.
It returns the number of usable bytes in the object represented
by
.IR oid ,
a handle to an object allocated by
.BR pmemobj_malloc ()
or a related function.
If
.I oid
is OID_NULL, 0 is returned.
.SH NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS
.PP
Besides the internal objects collections described in section
.B OBJECT CONTAINERS
the
.BR libpmemobj
provides a mechanism to organize persistent objects in the user-defined
persistent atomic circular doubly linked lists.  All the routines and macros
operating on the persistent lists provide atomicity with respect to
any power-fail interruptions.
If any of those operations is torn by program failure or system crash;
on recovery they are guaranteed to be entirely completed or discarded,
leaving the lists, persistent memory heap and internal object containers in
a consistent state.
.PP
The persistent atomic circular doubly linked lists support the following
functionality:
.IP
* Insertion of an object at the head of the list, or at the end of the list.
.IP
* Insertion of an object before or after any element in the list.
.IP
* Atomic allocation and insertion of a new object at the head of the list,
or at the end of the list.
.IP
* Atomic allocation and insertion of a new object before or after any element
in the list.
.IP
* Atomic moving of an element from one list to the specific location on another
list.
.IP
* Removal of any object in the list.
.IP
* Atomic removal and freeing of any object in the list.
.IP
* Forward or backward traversal through the list.
.PP
A list is headed by a
.I list_head
structure containing a single object handle of the first element on the list.
The elements are doubly linked so that an arbitrary element can be
removed without a need to traverse the list.  New elements can be added to the
list before or after an existing element, at the head of the list, or at the
end of the list.  A list may be traversed in either direction.
.PP
The user-defined structure of each element must contain a field of type
.BR list_entry
holding the object handles to the previous and next element on the list.
Both the
.BR list_head
and the
.BR list_entry
structures are declared in
.BR <libpmemobj.h> .
.PP
The functions below are intended to be used outside transactions - transactional
variants are described in section
.BR "TRANSACTIONAL OBJECT MANIPULATION" .
Note that operations performed using this non-transactional API are independent
from their transactional counterparts.  If any non-transactional allocations
or list manipulations are performed within an open transaction, the changes
will not be rolled-back if such a transaction is aborted or interrupted.
.PP
.BI "int pmemobj_list_insert(PMEMobjpool *" pop ", size_t " pe_offset ",
.br
.BI "     PMEMoid " dest ", PMEMoid *" head ", int " before ", PMEMoid " oid );
.IP
The
.BR pmemobj_list_insert
function inserts an element represented by object handle
.I oid
into the list referenced by
.IR head .
Depending on the value of flag
.IR before ,
the object is added before or after the element
.IR dest .
If
.I dest
value is OID_NULL, the object is inserted at the head or at the end of the list,
depending on the
.I before
flag value.
The argument
.I pe_offset
declares an offset of the structure that connects the elements in the list.
All the handles
.IR head ,
.I dest
and
.I oid
must point to the objects allocated from the same memory pool
.IR pop .
The
.I head
and
.I oid
cannot be OID_NULL.
On success, zero is returned. On error, -1 is returned and errno is set.
.PP
.BI "PMEMoid pmemobj_list_insert_new(PMEMobjpool *" pop ", size_t " pe_offset ",
.br
.BI "    PMEMoid " dest ", PMEMoid *" head ", int " before ", size_t " size ",
.br
.BI "    int " type_num ", void (*" constructor ")(void *" ptr ", void *" arg "), void *" arg );
.IP
The
.BR pmemobj_list_insert_new
function atomically allocates a new object of given
.I size
and type
.I type_num
and inserts it into the list referenced by
.IR head .
Depending on the value of
.I before
flag, the newly allocated object is added before or after the element
.IR dest .
If
.I dest
value is OID_NULL, the object is inserted at the head or at the end of the list,
depending on the
.I before
flag value.
The argument
.I pe_offset
declares an offset of the structure that connects the elements in the list.
All the handles
.IR head ,
.I dest
must point to the objects allocated from the same memory pool
.IR pop .
Before returning, it calls the
.BR constructor
function passing the pointer to the newly allocated object in
.I ptr
along with the
.I arg
argument.
It is guaranteed that allocated object is either
properly initialized or, if the allocation is interrupted before the constructor
completes, the memory space reserved for the object is reclaimed.
The
.I head
cannot be OID_NULL.
The allocated object is also also added to the internal container
associated with given
.IR type_num .
as described in section
.BR "OBJECT CONTAINERS" .
On success, it returns a handle to the newly allocated object.
On error, OID_NULL is returned and errno is set.
.PP
.BI "int pmemobj_list_remove(PMEMobjpool *" pop ", size_t " pe_offset ",
.br
.BI "     PMEMoid " oid ", PMEMoid *" head ", int " free );
.IP
The
.BR pmemobj_list_remove
function removes the object referenced by
.I oid
from the list pointed by
.IR head .
If
.I free
flag is set, it also removes the object from the internal object container and
frees the associated memory space.
The argument
.I pe_offset
declares an offset of the structure that connects the elements in the list.
Both
.I head
and
.I oid
must point to the objects allocated from the same memory pool
.I pop
and cannot be OID_NULL.
On success, zero is returned. On error, -1 is returned and errno is set.
.PP
.BI "int pmemobj_list_move(PMEMobjpool *" pop ,
.br
.BI "    size_t " pe_old_offset ", size_t " pe_new_offset ,
.br
.BI "    PMEMoid *" head_old ", PMEMoid *" head_new ", int " tail ", PMEMoid " oid );
.IP
The
.BR pmemobj_list_move
function moves the object represented by
.I oid
from the list pointed by
.I head_old
to the list pointed by
.IR head_new .
Depending on the value of flag
.IR before ,
the newly allocated object is added before or after the element
.IR dest .
If
.I dest
value is OID_NULL, the object is inserted at the head or at the end of the
second list, depending on the
.I before
flag value.
The arguments
.I pe_old_offset
and
.I pe_new_offset
declare the offsets of the structures that connects the elements in
the old and new lists respectively.
All the handles
.IR head_old ,
.IR head_new ,
.I dest
and
.I oid
must point to the objects allocated from the same memory pool
.IR pop .
.IR head_old ,
.I head_new
and
.I oid
cannot be OID_NULL.
On success, zero is returned. On error, -1 is returned and errno is set.
.SH TYPE-SAFE NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS
.PP
The following macros define and operate on a type-safe persistent atomic
circular doubly linked list data structure that consist of a set of persistent
objects of a well-known type.  Unlike the functions described
in the previous section, these macros provide type enforcement by requiring
declaration of type of the objects stored in given list, and not allowing
mixing objects of different types in a single list.
.PP
The functionality and semantics of those macros is similar to circular queues
defined in
.BR queue (3) .
.PP
The majority of the macros must specify the handle to the memory pool
.I pop
and the name of the
.I field
in the user-defined structure, which must be of type
.I POBJ_LIST_ENTRY
and is used to connect the elements in the list.
.PP
A list is headed by a structure defined by the
.I POBJ_LIST_HEAD
macro.  This structure contains an object handle of the first element on the
list.  The elements are doubly linked so that an arbitrary element can be
removed without a need to traverse the list.  New elements can be added to the
list before or after an existing element, at the head of the list, or at the
end of the list.  A list may be traversed in either direction.  A
.BR POBJ_LIST_HEAD
structure is declared as follows:
.IP
.nf
#define POBJ_LIST_HEAD(HEADNAME, TYPE)
struct HEADNAME {
    OID_TYPE(TYPE) pe_first;
    PMEMmutex lock;
};
.fi
.PP
In the macro definitions,
.I TYPE
is the name of a user-defined structure, that must contain a field of type
.IR POBJ_LIST_ENTRY .
The argument
.I HEADNAME
is the name of a user-defined structure that must be declared using the macro
.IR POBJ_LIST_HEAD .
See the examples below for further explanation of how these macros are used.
.PP
The macro
.BR POBJ_LIST_ENTRY
declares a structure that connects the elements in the list.
.IP
.nf
#define POBJ_LIST_ENTRY(TYPE)
struct {
    OID_TYPE(TYPE) pe_next;
    OID_TYPE(TYPE) pe_prev;
};
.fi
.PP
.BI "POBJ_LIST_FIRST(POBJ_LIST_HEAD *" head )
.IP
The macro
.BR POBJ_LIST_FIRST
returns the first element on the list referenced by
.IR head .
If the list is empty OID_NULL is returned.
.PP
.BI "POBJ_LIST_LAST(POBJ_LIST_HEAD *" head ", POBJ_LIST_ENTRY " FIELD )
.IP
The macro
.BR POBJ_LIST_LAST
returns the last element on the list referenced by
.IR head .
If the list is empty OID_NULL is returned.
.PP
.BI "POBJ_LIST_EMPTY(POBJ_LIST_HEAD *" head )
.IP
The macro
.BR POBJ_LIST_EMPTY
evaluates to 1 if the list referenced by
.I head
is empty.  Otherwise, 0 is returned.
.PP
.BI "POBJ_LIST_NEXT(OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD )
.IP
The macro
.BR POBJ_LIST_NEXT
returns the element from the list referenced by
.I head
next to the element
.IR elm .
If
.I elm
is the last element on the list, OID_NULL is returned.
.PP
.BI "POBJ_LIST_PREV(OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD )
.IP
The macro
.BR POBJ_LIST_PREV
returns the element from the list referenced by
.I head
preceding the element
.IR elm .
If
.I elm
is the first element on the list, OID_NULL is returned.
.PP
.BI "POBJ_LIST_FOREACH(OID_TYPE " var ", POBJ_LIST_HEAD *" head ",
.br
.BI "    POBJ_LIST_ENTRY " FIELD )
.IP
The macro
.BR POBJ_LIST_FOREACH
traverses the list referenced by
.I head
assigning a handle to each element in turn to
.I var
variable.
.PP
.BI "POBJ_LIST_FOREACH_REVERSE(OID_TYPE " var ", POBJ_LIST_HEAD *" head ",
.br
.BI "    POBJ_LIST_ENTRY " FIELD )
.IP
The macro
.BR POBJ_LIST_FOREACH_REVERSE
traverses the list referenced by
.I head
in reverse order, assigning a handle to each element in turn to
.I var
variable.
The
.I field
argument is the name of the field of type
.I POBJ_LIST_ENTRY
in the element structure.
.PP
.BI "POBJ_LIST_INSERT_HEAD(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.br
.BI "    OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD )
.IP
The macro
.BR POBJ_LIST_INSERT_HEAD
inserts the element
.I elm
at the head of the list referenced by
.IR head .
.PP
.BI "POBJ_LIST_INSERT_TAIL(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.br
.BI "    OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD )
.IP
The macro
.BR POBJ_LIST_INSERT_TAIL
inserts the element
.I elm
at the end of the list referenced by
.IR head .
.PP
.BI "POBJ_LIST_INSERT_AFTER(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.br
.BI "    OID_TYPE " listelm ", OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD )
.IP
The macro
.BR POBJ_LIST_INSERT_AFTER
inserts the element
.I elm
into the list referenced by
.I head
after the element
.IR listelm .
.PP
.BI "POBJ_LIST_INSERT_BEFORE(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.br
.BI "    OID_TYPE " listelm ", OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD )
.IP
The macro
.BR POBJ_LIST_INSERT_BEFORE
inserts the element
.I elm
into the list referenced by
.I head
before the element
.IR listelm .
.PP
.BI "POBJ_LIST_INSERT_NEW_HEAD(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.br
.BI "    int " type_num ", POBJ_LIST_ENTRY " FIELD ,
.br
.BI "    void (*" constructor ")(void *" ptr ", void *" arg "), void *" arg );
.IP
The macro
.BR POBJ_LIST_INSERT_NEW_HEAD
atomically allocates a new object of type
.I type_num
and inserts it at the head of the list referenced by
.IR head .
The newly allocated object is also added to the internal object
container associated with
.IR type_num .
.PP
.BI "POBJ_LIST_INSERT_NEW_TAIL(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.br
.BI "    int " type_num ", POBJ_LIST_ENTRY " FIELD ,
.br
.BI "    void (*" constructor ")(void *" ptr ", void *" arg "), void *" arg );
.IP
The macro
.BR POBJ_LIST_INSERT_NEW_TAIL
atomically allocates a new object of type
.I type_num
and inserts it at the tail of the list referenced by
.IR head .
The newly allocated object is also added to the internal object
container associated with
.IR type_num .
.PP
.BI "POBJ_LIST_INSERT_NEW_AFTER(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.br
.BI "    OID_TYPE " listelm ", int " type_num ", POBJ_LIST_ENTRY " FIELD ,
.br
.BI "    void (*" constructor ")(void *" ptr ", void *" arg "), void *" arg );
.IP
The macro
.BR POBJ_LIST_INSERT_NEW_AFTER
atomically allocates a new object of type
.I type_num
and inserts it into the list referenced by
.I head
after the element
.IR listelm .
The newly allocated object is also added to the internal object
container associated with
.IR type_num .
.PP
.BI "POBJ_LIST_INSERT_NEW_BEFORE(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.br
.BI "    OID_TYPE " listelm ", int " type_num ", POBJ_LIST_ENTRY " FIELD ,
.br
.BI "    void (*" constructor ")(void *" ptr ", void *" arg "), void *" arg );
.IP
The macro
.BR POBJ_LIST_INSERT_NEW_BEFORE
atomically allocates a new object of type
.I type_num
and inserts it into the list referenced by
.I head
before the element
.IR listelm .
The newly allocated object is also added to the internal object
container associated with
.IR type_num .
.PP
.BI "POBJ_LIST_REMOVE(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.br
.BI "    OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD )
.IP
The macro
.BR POBJ_LIST_REMOVE
removes the element
.I elm
from the list referenced by
.IR head .
.PP
.BI "POBJ_LIST_REMOVE_FREE(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.br
.BI "    OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD )
.IP
The macro
.BR POBJ_LIST_REMOVE_FREE
removes the element
.I elm
from the list referenced by
.I head
and frees the memory space represented by this element.
.PP
.BI "POBJ_LIST_MOVE_ELEMENT_HEAD(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.br
.BI "    POBJ_LIST_HEAD *" head_new ", OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD ",
.br
.BI "    POBJ_LIST_ENTRY " field_new )
.IP
The macro
.BR POBJ_LIST_MOVE_ELEMENT_HEAD
moves the element
.I elm
from the list referenced by
.I head
to the head of the list
.IR head_new .
The
.I field
and
.I field_new
arguments are the names of the fields of type
.I POBJ_LIST_ENTRY
in the element structure that are used to connect the elements in both lists.
.PP
.BI "POBJ_LIST_MOVE_ELEMENT_TAIL(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.br
.BI "    POBJ_LIST_HEAD *" head_new ", OID_TYPE " elm ", POBJ_LIST_ENTRY " FIELD ",
.br
.BI "    POBJ_LIST_ENTRY " field_new )
.IP
The macro
.BR POBJ_LIST_MOVE_ELEMENT_TAIL
moves the element
.I elm
from the list referenced by
.I head
to the end of the list
.IR head_new .
The
.I field
and
.I field_new
arguments are the names of the fields of type
.I POBJ_LIST_ENTRY
in the element structure that are used to connect the elements in both lists.
.PP
.BI "POBJ_LIST_MOVE_ELEMENT_AFTER(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.br
.BI "    POBJ_LIST_HEAD *" head_new ", OID_TYPE " listelm ", OID_TYPE " elm ",
.br
.BI "    POBJ_LIST_ENTRY " FIELD ", POBJ_LIST_ENTRY " field_new )
.IP
The macro
.BR POBJ_LIST_MOVE_ELEMENT_AFTER
atomically removes the element
.I elm
from the list referenced by
.I head
and inserts it into the list referenced by
.I head_new
after the element
.IR listelm .
The
.I field
and
.I field_new
arguments are the names of the fields of type
.I POBJ_LIST_ENTRY
in the element structure that are used to connect the elements in both lists.
.PP
.BI "POBJ_LIST_MOVE_ELEMENT_BEFORE(PMEMobjpool *" pop ", POBJ_LIST_HEAD *" head ",
.br
.BI "    POBJ_LIST_HEAD *" head_new ", OID_TYPE " listelm ", OID_TYPE " elm ",
.br
.BI "    POBJ_LIST_ENTRY " FIELD ", POBJ_LIST_ENTRY " field_new )
.IP
The macro
.BR POBJ_LIST_MOVE_ELEMENT_BEFORE
atomically removes the element
.I elm
from the list referenced by
.I head
and inserts it into the list referenced by
.I head_new
before the element
.IR listelm .
The
.I field
and
.I field_new
arguments are the names of the fields of type
.I POBJ_LIST_ENTRY
in the element structure that are used to connect the elements in both lists.
.SH TRANSACTIONAL OBJECT MANIPULATION
.PP
The functions described in sections
.B NON-TRANSACTIONAL ATOMIC ALLOCATIONS
and
.B NON-TRANSACTIONAL PERSISTENT ATOMIC LISTS
only guarantee the atomicity in scope of a single operation on an object.
In case of more complex changes, involving multiple operations on an object,
or allocation and modification of multiple objects; data consistency
and fail-safety may be provided only by using
.IR "atomic transactions" .
.PP
A transaction is defined as series of operations on persistent memory objects
that either all occur, or nothing occurs.  In particular, if the execution
of a transaction is interrupted by a power failure or a system crash,
it is guaranteed that after system restart, all the changes made as a part
of the uncompleted transaction will be rolled-back, restoring the consistent
state of the memory pool from the moment when the transaction was started.
.PP
Note that transactions do not provide the atomicity with respect to
other threads.  All the modifications performed within the transactions are
immediately visible to other threads, and this is the responsibility of
the program to implement a proper thread synchronization mechanism.
.PP
Each transaction is visible only for the thread that started it.
No other threads can add operations, commit or abort the transaction initiated
by another thread.
There may be multiple open transactions on given memory pool at the same time,
but only one transaction per thread.
.PP
Nested transactions are supported but flattened.
Committing the nested transaction does not commit the outer
transaction, however errors in the nested transaction are propagated up to
the outer-most level, resulting in the interruption of the entire transaction.
.PP
.BI "enum tx_stage pmemobj_tx_stage();
.IP
The
.BR pmemobj_tx_stage ()
function returns the stage of the current transaction stage for a thread.
Stages are changed only by the
.I pmemobj_tx_*
functions.  The transaction stages are defined as follows:
.IP
.BR TX_STAGE_NONE
- no open transaction in this thread
.IP
.BR TX_STAGE_WORK
- transaction in progress
.IP
.BR TX_STAGE_ONCOMMIT
- successfully committed
.IP
.BR TX_STAGE_ONABORT
- starting the transaction failed or transaction aborted
.IP
.BR TX_STAGE_FINALLY
- ready for clean up
.PP
.BI "int pmemobj_tx_begin(PMEMobjpool *" pop ", jmp_buf *" env ", " ... );
.IP
The
.BR pmemobj_tx_begin ()
function starts a new transaction in the current thread.
If called within an open transaction, it starts a nested transaction.
The caller may use
.I env
argument to provide a pointer to the information of a calling environment
to be restored in case of transaction abort.  This information must be filled
by a caller, using
.BR setjmp (3)
macro.
.IP
Optionally, a list of pmem-resident locks may be provided as the last arguments.
Each lock is specified by a pair of lock type (
.I TX_LOCK_MUTEX
or
.IR TX_LOCK_RWLOCK )
and the pointer to the lock of type
.I PMEMmutex
or
.I PMEMrwlock
respectively.  The list must be terminated with
.IR TX_LOCK_NONE .
In case of rwlocks, a write lock is acquired.  It is guaranteed that
.BR pmemobj_tx_begin ()
will grab all the locks prior to successful completion and they will be held
by the current thread until the transaction is finished.
Locks are taken in the order from left to right.  To avoid deadlocks, user must
take care about the proper order of locks.
.IP
New transaction may be started only if the current stage is
.I TX_STAGE_NONE
or
.IR TX_STAGE_WORK .
If successful, transaction stage changes to
.I TX_STAGE_WORK
and function
returns zero.  Otherwise, stage changes to
.I TX_STAGE_ONABORT
and an error number is returned.
.PP
.BI "void pmemobj_tx_abort(int " errnum );
.IP
The
.BR pmemobj_tx_abort ()
aborts the current transaction and causes transition to
.IR TX_STAGE_ONABORT .
It has no effect if called during the stage other than
.IR TX_STAGE_WORK .
.PP
.BI "int pmemobj_tx_commit();
.IP
The
.BR pmemobj_tx_commit ()
function commits the current open transaction and causes transition to
.I TX_STAGE_ONCOMMIT
stage.  If called in context of the outer-most transaction,
all the changes may be considered as durably written upon successful completion.
If successful returns 0.  Otherwise, an error number is returned.
It has no effect if called during the stage other than
.IR TX_STAGE_WORK .
.PP
.BI "void pmemobj_tx_end();
.IP
The
.BR pmemobj_tx_end ()
function performs a clean up of a current transaction.  If called in context
of the outer-most transaction, it releases all the locks acquired by
.BR pmemobj_tx_begin ()
for outer and nested transactions.  Then it causes the transition to
.IR TX_STAGE_NONE .
In case of the nested transaction, it returns to the context of the outer
transaction with
.I TX_STAGE_WORK
stage without releasing any locks.
Must always be called for each
.BR pmemobj_tx_begin (),
even if starting the transaction failed.  It has no effect if called
during
.I TX_STAGE_NONE
stage.
.PP
.BI "int pmemobj_tx_process();
.IP
The
.BR pmemobj_tx_process ()
function performs the actions associated with current stage of the transaction,
and makes the transition to the next stage.  Current stage must always
be obtained by a call to
.BR pmemobj_tx_get_stage ().
If successful, function returns zero.  Otherwise, an error number is returned.
.PP
.BI "int pmemobj_tx_add_range(uint64_t " off ", size_t " size );
.IP
The
.BR pmemobj_tx_add_range ()
takes a "snapshot" of the memory block of given
.I size
and located at given offset in the object specified by
.IR off ,
and saves it to the undo log.  The application is then free to directly modify
the object in that memory range.  In case of a failure or abort, all the changes
within this range will be rolled-back.
If successful and called during
.I TX_STAGE_WORK
function returns zero.  Otherwise, state changes to
.I TX_STAGE_ONABORT
and an error number is returned.
.PP
.BI "PMEMoid pmemobj_tx_alloc(size_t " size ", int " type_num );
.IP
The
.BR pmemobj_tx_alloc ()
transactionally allocates a new object of given
.I size
and
.IR type_num .
In contrast to the non-transactional allocations, the objects are
added to the internal object containers of given
.I type_num
only after the transaction is committed, making the objects visible to the
.BR PMEMOBJ_FOREACH_*
macros.
If successful and called during
.I TX_STAGE_WORK
function returns a handle to the newly allocated object.  Otherwise, stage
changes to
.IR TX_STAGE_ONABORT ,
OID_NULL is returned, and errno is set appropriately.
If
.I size
is 0, OID_NULL is returned.
.PP
.BI "PMEMoid pmemobj_tx_zalloc(size_t " size ", int " type_num );
.IP
The pmemobj_tx_zalloc ()
.BR
function transactionally allocates new zeroed object of given
.I size
and
.IR type_num .
If successful and called during
.I TX_STAGE_WORK
function returns a handle to the newly allocated object.  Otherwise, stage
changes to
.IR TX_STAGE_ONABORT ,
OID_NULL is returned, and errno is set appropriately.
.PP
.BI "PMEMoid pmemobj_tx_realloc(PMEMoid " oid ", size_t " size ", int " type_num );
.IP
The
.BR pmemobj_tx_realloc ()
function transactionally resizes an existing object to the given
.I size
and changes its type to
.IR type_num .
If
.I oid
is OID_NULL, then the call is equivalent to
.IR "pmemobj_tx_alloc(pop, size, type_num)" ;
if
.I size
is equal to zero, and
.I oid
is not OID_NULL, then the call is equivalent to
.IR "pmemobj_tx_free(oid)" .
If the new size is larger than the old size, the added memory will
.I not
be initialized.
If successful and called during
.I TX_STAGE_WORK
function returns returns a handle to the resized object.  Otherwise, stage
changes to
.IR TX_STAGE_ONABORT ,
OID_NULL is returned, and errno is set appropriately.
Note that the object handle value may change in result of reallocation.
.PP
.BI "PMEMoid pmemobj_tx_zrealloc(PMEMoid " oid ", size_t " size ", int " type_num );
.IP
The
.BR pmemobj_tx_zrealloc ()
function transactionally resizes an existing object to the given
.I size
and changes its type to
.IR type_num .
If the new size is larger than the old size, the extended new space is zeroed.
If successful and called during
.I TX_STAGE_WORK
function returns returns a handle to the resized object.  Otherwise, stage
changes to
.IR TX_STAGE_ONABORT ,
OID_NULL is returned, and errno is set appropriately.
Note that the object handle value may change in result of reallocation.
.PP
.BI "PMEMoid pmemobj_tx_strdup(const char *" s ", int " type_num );
.IP
The
.BR pmemobj_tx_strdup ()
function transactionally allocates a new object containing a duplicate of the
string
.I s
and assigns it a type
.IR type_num .
If successful and called during
.I TX_STAGE_WORK
function returns a handle to the newly allocated object.  Otherwise, stage
changes to
.IR TX_STAGE_ONABORT ,
OID_NULL is returned, and errno is set appropriately.
.PP
.BI "int pmemobj_tx_free(PMEMoid " oid );
.IP
The
.BR pmemobj_tx_free ()
function transactionally frees an existing object referenced by
.IR oid .
If successful and called during
.I TX_STAGE_WORK
function returns zero. Otherwise, stage changes to
.I TX_STAGE_ONABORT
and an error number is returned.
.PP
In addition to the above API, the
.BR libpmemobj
offers a more intuitive method of building transactions using a set of macros
described below.  When using macros, the complete transaction flow looks like
this:
.IP
.nf
TX_BEGIN(Pop) {
	/* the actual transaction code goes here... */
} TX_ONCOMMIT {
	/*
	 * optional - executed only if the above block
	 * successfully completes
	 */
} TX_ONABORT {
	/*
	 * optional - executed only if starting the transaction fails,
	 * or if transaction is aborted by an error or a call to
	 * pmemobj_tx_abort()
	 */
} TX_FINALLY {
	/*
	 * optional - if exists, it is executed after
	 * TX_ONCOMMIT or TX_ONABORT block
	 */
} TX_END /* mandatory */
.fi
.PP
.BI "TX_BEGIN_LOCK(PMEMobjpool *" pop ", " ... )
.sp
.BI "TX_BEGIN(PMEMobjpool *" pop )
.IP
The
.BR TX_BEGIN_LOCK ()
and
.BR TX_BEGIN ()
macros start a new transaction in the same way as
.BR pmemobj_tx_begin (),
except that instead of the environment buffer provided by a caller,
they set up the local
.I jmp_buf
buffer and use it to catch the transaction abort.
The
.BR TX_BEGIN ()
macro may be used in case when there is no need to grab any locks prior to
starting a transaction (like for a single-threaded program).
Each of those macros shall be followed by a block of code with all the
operations that are to be performed atomically.
.PP
.BI "TX_ONABORT
.IP
The
.BR TX_ONABORT ()
macro starts a block of code that will be executed only if starting the
transaction fails due to an error in
.BR pmemobj_tx_begin (),
or if the transaction is aborted.
This block is optional.
.PP
.BI "TX_ONCOMMIT
.IP
The
.BR TX_ONCOMMIT ()
macro starts a block of code that will be executed only if the transaction
is successfully committed, which means that the execution of code in
.BR TX_BEGIN
block has not been interrupted by an error or by a call to
.BR pmemobj_tx_abort ().
This block is optional.
.PP
.BI "TX_FINALLY
.IP
The
.BR TX_FINALLY ()
macro starts a block of code that will be executed regardless of whether
the transaction is committed or aborted.  This block is optional.
.PP
.BI "TX_END
.IP
The
.BR TX_END ()
macro cleans up and closes the transaction started by
.BR TX_BEGIN ()
or
.BR TX_BEGIN_LOCK ()
macro.  It is mandatory to terminate each transaction with this macro.
.PP
Similarly to the macros controlling the transaction flow, the
.BR libpmemobj
defines a set of macros that simplify the transactional operations on
persistent objects.  Note that those macros operate on typed object handles,
thus eliminating the need to specify the size of the object, or the size
and offset of the field in the user-defined structure that is
to be modified.
.PP
.BI "TX_ADD_FIELD(OID_TYPE " o ", " FIELD )
.IP
The
.BR TX_ADD_FIELD ()
macro saves in the undo log the current value of given
.I FIELD
of the object referenced by a handle
.IR o.
The application is then free to directly modify the specified
.IR FIELD .
In case of a failure or abort, the saved value will be restored.
.PP
.BI "TX_ADD(OID_TYPE " o )
.IP
The
.BR TX_ADD ()
macro takes a "snapshot" of the entire object referenced by object handle
.I o
and saves it in the undo log.  The object size is determined from its
.IR TYPE .
The application is then free to directly modify the object.  In case of
a failure or abort, all the changes within the object will be rolled-back.
.PP
.BI "TX_SET(OID_TYPE " o ", " FIELD ", " VALUE )
.IP
The
.BR TX_SET
macro saves in the undo log the current value of given
.I FIELD
of the object referenced by a handle
.IR o ,
and then set its new
.IR VALUE .
In case of a failure or abort, the saved value will be restored.
.PP
.BI "TX_MEMCPY(OID_TYPE " o ", " FIELD ", const void *" src ", size_t " num )
.IP
The
.BR TX_MEMCPY
macro saves in the undo log the current value of given
.I FIELD
of the object referenced by a handle
.IR o ,
and then overwrites the first
.I num
bytes of its memory area with the data copied from the buffer pointed by
.IR src .
In case of a failure or abort, the saved value will be restored.
.PP
.BI "TX_MEMSET(OID_TYPE " o ", " FIELD ", int " c ", size_t " num )
.IP
The
.BR TX_MEMSET
macro saves in the undo log the current value of given
.I FIELD
of the object referenced by a handle
.IR o ,
and then fills the first
.I num
bytes of its memory area with the constant byte
.IR c .
In case of a failure or abort, the saved value will be restored.
.PP
.BI "TX_ALLOC(" TYPE ", int " type_num )
.IP
The
.BR TX_ALLOC ()
macro transactionally allocates an new object of given
.I TYPE
and assigns it a type number
.IR type_num .
The allocation size is determined from the size of the
user-defined structure
.IR TYPE .
This macro may only be called from inside the
.BR OID_ASSIGN
macro, like in the following example:
.IP
.nf
OID_TYPE(struct mytype) o;
OID_ASSIGN(o, TX_ALLOC(struct mytype, MYTYPE_NUM));
.fi
.IP
If successful and called during
.I TX_STAGE_WORK
it returns a handle to the newly allocated object.  Otherwise, stage
changes to
.IR TX_STAGE_ONABORT ,
OID_NULL is returned, and errno is set appropriately.
.PP
.BI "TX_ZALLOC(" TYPE ", int " type_num )
.IP
The
.BR TX_ZALLOC ()
macro transactionally allocates a new zeroed object of given
.I TYPE
and assigns it a type number
.IR type_num .
The allocation size is determined from the size of the
user-defined structure
.IR TYPE .
Similarly to
.BR TX_ALLOC (),
this macro may only be called from inside the
.BR OID_ASSIGN
macro.
If successful and called during
.I TX_STAGE_WORK
it returns a handle to the newly allocated object.  Otherwise, stage
changes to
.IR TX_STAGE_ONABORT ,
OID_NULL is returned, and errno is set appropriately.
.PP
.BI "TX_REALLOC(OID_TYPE " o ", size_t " size ", int " type_num )
.IP
The
.BR TX_REALLOC ()
macro transactionally resizes an existing object referenced by a handle
.I o
to the given
.I size
and changes its type to
.IR type_num .
Similarly to
.BR TX_ALLOC (),
this macro may only be called from inside the
.BR OID_ASSIGN
macro.
If successful and called during
.I TX_STAGE_WORK
it returns a handle to the reallocated object.  Otherwise, stage
changes to
.IR TX_STAGE_ONABORT ,
OID_NULL is returned, and errno is set appropriately.
.PP
.BI "TX_ZREALLOC(OID_TYPE " o ", size_t " size ", int " type_num )
.IP
The
.BR TX_ZREALLOC ()
macro transactionally resizes an existing object referenced by a handle
.I o
to the given
.I size
and changes its type to
.IR type_num .
If the new size is larger than the old size, the extended new space is zeroed.
Similarly to
.BR TX_ALLOC (),
this macro may only be called from inside the
.BR OID_ASSIGN
macro.
If successful and called during
.I TX_STAGE_WORK
it returns a handle to the reallocated object.  Otherwise, stage
changes to
.IR TX_STAGE_ONABORT ,
OID_NULL is returned, and errno is set appropriately.
.PP
.BI "TX_STRDUP(const char *" s ", int " type_num )
.IP
The
.BR TX_STRDUP ()
macro transactionally allocates a new object containing a duplicate of the
string
.I s
and assigns it a type
.IR type_num .
Similarly to
.BR TX_ALLOC (),
this macro may only be called from inside the
.BR OID_ASSIGN
macro.
If successful and called during
.I TX_STAGE_WORK
it returns a handle to the newly allocated object.  Otherwise, stage
changes to
.IR TX_STAGE_ONABORT ,
OID_NULL is returned, and errno is set appropriately.
.PP
.BI "TX_FREE(OID_TYPE " o )
.IP
The
.BR TX_FREE ()
transactionally frees the memory space represented by an object handle
.IR o .
If
.I o
is OID_NULL, no operation is performed.
If successful and called during
.I TX_STAGE_WORK
it returns zero.  Otherwise, stage changes to
.I TX_STAGE_ONABORT
and an error number is returned.
.SH LIBRARY API VERSIONING
.PP
This section describes how the library API is versioned,
allowing applications to work with an evolving API.
.PP
.BI "const char *pmemobj_check_version("
.br
.BI "    unsigned " major_required ,
.br
.BI "    unsigned " minor_required );
.IP
The
.BR pmemobj_check_version ()
function is used to see if the installed
.B libpmemobj
supports the version of the library API required by an application.
The easiest way to do this is for the application to supply the
compile-time version information, supplied by defines in
.BR <libpmemobj.h> ,
like this:
.IP
.nf
reason = pmemobj_check_version(PMEMOBJ_MAJOR_VERSION,
                            PMEMOBJ_MINOR_VERSION);
if (reason != NULL) {
    /*  version check failed, reason string tells you why */
}
.fi
.IP
Any mismatch in the major version number is considered a failure,
but a library with a newer minor version number will pass this
check since increasing minor versions imply backwards compatibility.
.IP
An application can also check specifically for the existence of
an interface by checking for the version where that interface was
introduced.  These versions are documented in this man page as follows:
unless otherwise specified, all interfaces described here are available
in version 1.0 of the library.  Interfaces added after version 1.0
will contain the text
.I introduced in version x.y
in the section of this manual describing the feature.
.IP
When the version check performed by
.BR pmemobj_check_version ()
is successful, the return value is NULL.  Otherwise the return value
is a static string describing the reason for failing the version check.
The string returned by
.BR pmemobj_check_version ()
must not be modified or freed.
.SH MANAGING LIBRARY BEHAVIOR
.PP
The library entry points described in this section are less
commonly used than the previous sections.
.PP
.BI "void pmemobj_set_funcs("
.br
.BI "    void *(*" malloc_func ")(size_t " size ),
.br
.BI "    void (*" free_func ")(void *" ptr ));
.IP
The
.BR pmemobj_set_funcs ()
function allows an application to override memory allocation
calls used internally by
.BR libpmemobj .
Passing in NULL for any of the handlers will cause the
.B libpmemobj
default function to be used.
The library does not make heavy use of the system malloc functions, but
it does allocate approximately 4-8 kilobytes for each memory pool in use.
.PP
.BI "int pmemobj_check(const char *" path ", const char *" layout );
.IP
The
.BR pmemobj_check ()
function performs a consistency check of the file
indicated by
.I path
and returns 1 if the memory pool is found to be consistent.  Any
inconsistencies found will cause
.BR pmemobj_check ()
to return 0, in which case
the use of the file with
.B libpmemobj
will result in undefined behavior.  The debug version of
.B libpmemobj
will provide additional details on inconsistencies when
.B PMEMOBJ_LOG_LEVEL
is at least 1, as described in the
.B DEBUGGING
section below.
.BR pmemobj_check ()
will return -1 and set errno if it cannot perform the
consistency check due to other errors.
.BR pmemobj_check ()
opens the given
.I path
read-only so it never makes any changes to the file.
.SH DEBUGGING
.PP
Two versions of
.B libpmemobj
are typically available on a development system.
The normal version, accessed when a program is
linked using the
.B -lpmemobj
option, is optimized for performance.  That version skips checks
that impact performance and never logs any trace information or performs
any run-time assertions.  A second version, accessed when a program
uses the libraries under
.BR /usr/lib/nvml_debug ,
contains run-time assertions and trace points.
The typical way to access the debug version is to set the environment variable
.B LD_LIBRARY_PATH
to
.BR /usr/lib/nvml_debug
or
.BR /usr/lib64/nvml_debug
depending on where the debug libraries are installed on the system.
The trace points in the debug version of the library
are enabled using the environment variable
.BR PMEMOBJ_LOG_LEVEL ,
which can be set to the following values:
.IP 0
This is the default level when
.B PMEMOBJ_LOG_LEVEL
is not set.  No log messages are emitted at this level.
.IP 1
Additional details on any errors detected are logged (in addition
to returning the errno-based errors as usual).
.IP 2
A trace of basic operations is logged.
.IP 3
This level enables a very verbose amount of function call tracing
in the library.
.IP 4
This level enables voluminous and fairly obscure tracing information
that is likely only useful to the
.B libpmemobj
developers.
.PP
The environment variable
.B PMEMOBJ_LOG_FILE
specifies a file name where all logging information should be written.
If the last character in the name is "-", the PID of the current process
will be appended to the file name when the log file is created.  If
.B PMEMOBJ_LOG_FILE
is not set, the logging output goes to stderr.
.PP
Setting the environment variable
.B PMEMOBJ_LOG_LEVEL
has no effect on the non-debug version of
.BR libpmemobj .
.SH EXAMPLES
.PP
See http://pmem.io/nvml/libpmemobj for examples
using the
.B libpmemobj
API.
.SH ACKNOWLEDGEMENTS
.PP
.B libpmemobj
builds on the persistent memory programming model
recommended by the SNIA NVM Programming Technical Work Group:
.IP
http://snia.org/nvmp
.SH "SEE ALSO"
.BR mmap (2),
.BR munmap (2),
.BR msync (2),
.BR pthread_mutex (3),
.BR pthread_rwlock (3),
.BR pthread_cond (3),
.BR libpmemblk (3),
.BR libpmemlog (3),
.BR libpmem (3),
.BR libvmem (3)
and
.BR http://pmem.io .
